#INCLUDE "TOTVS.CH"
#INCLUDE "TLPP-CORE.TH"
#INCLUDE "TLPP-REST.TH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "TBICONN.CH"

/*/{Protheus.doc} U_PostProdutos
Criando novos produtos
@type function
@version 12.1.33
@author felip
@since 20/01/2023
/*/@POST("faturamento/produtos/create")
Function U_PostProdutos()

	Local aBody       := {}         as Array
	Local aDA1        := {}         as Array
	Local aDadosDA0   := {}         as Array
	Local aDadosDA1   := {}         as Array
	Local aDadosSB1   := {}         as Array
	Local aLogAuto    := {}         as Array
	Local aSB1        := {}         as Array
	Local cArqLog     := ""         as Character
	Local cCodigo     := ""         as Character
	Local cDirLog     := '\x_logs\' as Character
	Local cError      := ""         as Character
	Local cErrorLog   := ""         as Character
	Local cPedido     := ""         as Character
	Local cTitulo     := ""         as Character
	Local jBody       := Nil        as Json
	Local jHeader     := Nil        as Json
	local jResponse   := Nil        as Json
	Local lMsErroAuto := .F.        as Logical
	Local lRet        := .T.        as Logical
	Local nOBrig      := 0          as Numeric
	Local nOpcDA0     := 4          as Numeric
	Local nOpcSB1     := 3          as Numeric
	Local nX          := 0          as Numeric

	if SELECT("SX2") == 0 //Para ser executado pelo usuario
		PREPARE ENVIRONMENT EMPRESA "99" FILIAL "01"
	endif

	//Se não existir a pasta de logs, cria..
	IF ! ExistDir(cDirLog)
		MakeDir(cDirLog)
	EndIF

	// Cria um object Json
	jBody := JsonObject():new()

	// Cria um Json de resposta no final do proceso realizado
	jResponse := JsonObject():New()

	// Permite popular o JsonObject
	jBody:fromJson( oRest:GetBodyRequest() )

	// Pega o nome dos campos que foram passados na JSON
	aBody := jBody:GetNames()

	// Pega todos os campos da tabela de produtos
	aSB1 := FWSX3Util():GetAllFields( "SB1" , .T. )
	aDA1 := FWSX3Util():GetAllFields( "DA1" , .T. )

	// Retorna todo o cabecalho da requisicao
	jHeader := oRest:getHeaderRequest()

	// Pega o Json que foi enviado na requisição
	cError := jBody:FromJson(oRest:getBodyRequest())

	// Da uma SELECT na tabela de produtos
	DBSelectArea("SB1")

	// Setando qual Indice deve usar
	SB1->(DbSetOrder(1))

	// Posiciona na tabela de Preco
	DBSelectArea("DA0")

	// Indice que sera usado
	DA0->(dbSetOrder(1))

	//Se tiver algum erro no Parse, encerra a execução
	IF !Empty(cError)
		jResponse['errorId']  := 'NEW004'
		jResponse['error']    := 'Parse do JSON'
		jResponse['solution'] := 'Erro ao fazer o Parse do JSON'
	Else

		// Sobrescreve alguns campos para poder ser tudo gravado sem erro
		For nX := 1 to Len(aBody)
			IIF(aBody[nX] $ "Garantia"	 ,aBody[nX] := "Garantia?",)
			IIF(aBody[nX] $ "pedido"	 ,cPedido   := jBody["pedido"],)
			IIF(aBody[nX] $ "Armazem Pad",aBody[nX] := "Armazem Pad.",)
			IIF(aBody[nX] $ "Tipo Operac",aBody[nX] := "Tipo Operac.",)
			nOBrig := nOBrig + 1
		Next

		if (nOBrig == 13)

			// Resetando o valor
			nX := 0

			// Pega o nome dos campos que foram informados no Json criando uma string unica que contem todos os campos que foram informados
			cTitulo := Arrtokstr(aBody)

			For nX := 1 to Len(aSB1)
				If ALLTRIM(GetSX3Cache(aSB1[nX], 'X3_TITULO')) $ cTitulo
					nPosFild := aScan(aBody, ALLTRIM(GetSX3Cache(aSB1[nX], 'X3_TITULO')))
					aadd(aDadosSB1, {Alltrim(GetSX3Cache(aSB1[nX], 'X3_CAMPO')), jBody:GetJsonObject( aBody[nPosFild] ), Nil})
				EndIf
			Next

			// Resetando o valor
			nX := 0

			For nX := 1 to Len(aDadosSB1)
				//Se o campo for data, retira as barras e faz a conversão
				If GetSX3Cache(aDadosSB1[nX][1], 'X3_TIPO') == 'D'
					aDadosSB1[nX][2] := StrTran(aDadosSB1[nX][2], '/', '')
					aDadosSB1[nX][2] := sToD(aDadosSB1[nX][2])
				EndIf
				IIF(aDadosSB1[nX][1] $ "B1_COD",cCodigo := aDadosSB1[nX][2],)
			Next

			// Resetando o valor
			nX := 0

			// Passando uma tabela de preço ja existente
			aadd(aDadosDA0, {"DA0_CODTAB",cPedido, Nil})

			// Gerando os campos da tabela de itens do pedido de venda
			For nX := 1 to Len(aDA1)
				If ALLTRIM(GetSX3Cache(aDA1[nX], 'X3_TITULO')) $ cTitulo
					nPosFild := aScan(aBody, ALLTRIM(GetSX3Cache(aDA1[nX], 'X3_TITULO')))
					aadd(aDadosDA1, {Alltrim(GetSX3Cache(aDA1[nX], 'X3_CAMPO')), jBody:GetJsonObject( aBody[nPosFild] ), Nil})
				EndIf
			Next

			// Adicionando novo item na tabela preco
			aadd(aDadosDA1,{"DA1_ITEM",novoitem(),Nil})

			// Resetando o valor
			nX := 0

			For nX := 1 to Len(aDadosDA1)
				//Se o campo for data, retira as barras e faz a conversão
				If GetSX3Cache(aDadosDA1[nX][1], 'X3_TIPO') == 'D'
					aDadosDA1[nX][2] := StrTran(aDadosDA1[nX][2], '/', '')
					aDadosDA1[nX][2] := sToD(aDadosDA1[nX][2])
				EndIf
			Next

			// Resetando o valor
			nX := 0

			// Verifica se o produto ja existe na tabela
			if SB1->(!DBSeek(xFilial("SB1") + cCodigo))

				//Chama a inclusão automática
				MsExecAuto({|x, y| MATA010(x, y)}, aDadosSB1, nOpcSB1)


				//Se houve erro, gera um arquivo de log dentro do diretório da protheus data
				If lMsErroAuto

					//Monta o texto do Error Log que será salvo
					cErrorLog   := ""
					aLogAuto    := GetAutoGrLog()
					For nX := 1 To Len(aLogAuto)
						cErrorLog += aLogAuto[nX] + CRLF
					Next

					//Grava o arquivo de log
					cArqLog := 'PostProduto_' + dToS(Date()) + '_' + StrTran(Time(), ':', '-') + '.log'
					MemoWrite(cDirLog + cArqLog, cErrorLog)

					//Define o retorno para o WebService
					oRest:setStatusCode(500)
					jResponse['errorId']  := 'NEW005'
					jResponse['error']    := 'Erro na inclusão do produto: '
					jResponse['solution'] := 'Nao foi possivel incluir o produto, foi gerado um arquivo de log em ' + cDirLog + cArqLog + ' '

				else

					// Pocisiona no registro
					if DA0->(MsSeek(xFilial("DA0") + cPedido))

						// Executando a alteração da tabela de preço
						MsExecAuto({|x, y, z| OMSA010(x, y, z)}, aDadosDA0, aDadosDA1, nOpcDA0)

						//Se houve erro, gera um arquivo de log dentro do diretório da protheus data
						If lMsErroAuto

							//Monta o texto do Error Log que será salvo
							cErrorLog   := ""
							aLogAuto    := GetAutoGrLog()
							For nX := 1 To Len(aLogAuto)
								cErrorLog += aLogAuto[nX] + CRLF
							Next

							//Grava o arquivo de log
							cArqLog := 'PostProduto_' + dToS(Date()) + '_' + StrTran(Time(), ':', '-') + '.log'
							MemoWrite(cDirLog + cArqLog, cErrorLog)

							//Define o retorno para o WebService
							oRest:setStatusCode(500)
							jResponse['errorId']  := 'NEW005'
							jResponse['error']    := 'Erro na inclusão do produto na tabela de preco: '
							jResponse['solution'] := 'Nao foi possivel incluir o produto na tabela de preco, foi gerado um arquivo de log em ' + cDirLog + cArqLog + ' '

						else
							oRest:setStatusCode(200)
							jResponse['Registro'] := "Produto registrado com sucesso e gravado na tabela de preco"
						endif
					endif
				Endif

			else
				jResponse['error']  := 'Produto ja registrado na tabela de preço'
			endif
		else
			oRest:setStatusCode(404)
			jResponse['error']   := 'Produto nao pode ser cadastrado pois nao esta sendo seguindo o campos obrigatorios para fazer a inserção do produto'
			jResponse['solução'] := 'Campos que devem ser passados:'
			jResponse['campos']  := "Codigo, Descricao, Tipo, Unidade, Armazem Pad" + CHR(13)+CHR(10) + ;
				"arantia, pedido, Tipo Preco, Preco Venda, Ativo" + CHR(13)+CHR(10) + ;
				" Tipo Operac, Moeda, Vigencia"
		endif
	Endif

	if( jHeader <> Nil )
		//Definindo o header de resposta
		oRest:setKeyHeaderResponse('Connection','Keep-Alive')
		oRest:setKeyHeaderResponse('accept-encoding','gzip,deflate')
		oRest:setKeyHeaderResponse('accept','/')
		oRest:setKeyHeaderResponse('User-Agent','Thunder Client (https://www.thunderclient.com)')
	Endif

	//Define o retorno
	oRest:setKeyHeaderResponse('Content-Type','application/json') // Define a estrutura como Json
	oRest:setResponse(jResponse)

	if SELECT("SX2") > 0 // Finaliza operação pelo usuario
		RESET ENVIRONMENT
	endif

Return lRet

Static function novoitem()

	Local cAlias      := ""  as Character
	Local cFinalQuery := ""  as Character
	Local cQuery      := ""  as Character
	Local oQuery      := Nil as Object

	// Construtor da carga
	oQuery := FWPreparedStatement():New()

	// Query que será executada
	cQuery := "SELECT DA1_ITEM FROM DA1990 WHERE D_E_L_E_T_ <>  '*'"

	// Informa a query a ser executada, deve ser utilizada a construção com os parametros com "?"
	oQuery:SetQuery(cQuery)

	// Retorna a query com os parâmetros já tratados e substituídos
	cFinalQuery := oQuery:GetFixQuery()

	// Abre um alias com a query informada
	cAlias := MPSysOpenQuery(cFinalQuery)

	while (cAlias)->(Eof())
		cValItem := VAL((cAlias)->DA1_ITEM) + 1
		(cAlias)->(DbSkip())
	end

	cValItem := cValToChar(cValItem)

Return cValItem
/*
1=Preco Venda;2=Venda Consumidor;3=Atacado;4=Varejo;5=Promocao A

1=Sim;2=Nao B

1=Estadual;2=InterEstadual;3=Norte/Nordeste;4=Todos C

{
	"Codigo": "000000000000002",
	"Descricao": "CADEIRA",
	"Tipo": "MC",
	"Unidade": "UN",
	"Armazem Pad.": "01",
	"Garantia": "2", B
	"pedido": "001",
	"Tipo Preco": "Preco Venda", A
	"Preco Venda": 1200.00,
	"Ativo": "Sim",
	"Tipo Operac.": "Estadual", C
	"Moeda": "1",
	"Vigencia": "24/06/2023"
}
*/
