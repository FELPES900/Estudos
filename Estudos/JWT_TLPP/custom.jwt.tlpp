#INCLUDE "TOTVS.CH"
#INCLUDE "TLPP-CORE.TH"
#INCLUDE "TLPP-REST.TH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "TBICONN.CH"

Static cKey := "b44de0df9003385ea2431e35befff44fa0a3d51a"

/*/{Protheus.doc} U_JWTTOKEN
Criaçãpo de token usando JWT para segurança
@type function
@version 12.23.10
@author Felipe Fraga
@since 10/01/2024
@return variant, return
/*/@POST("jwt/token")
Function U_JWTTOKEN()

    Local aBody     := {}                 as Array
    Local jResponse := JsonObject():New() as Json
    Local oJson     := JsonOBject():New() as Json
    Local oJwt      := JsonObject():New() as Json
    Local oPayload  := JsonObject():New() as Json

    if SELECT("SX2") == 0 //Para ser executado pelo usuario
      PREPARE ENVIRONMENT EMPRESA "99" FILIAL "01"
    endif
    
    oJwt := Jwt():New(cKey, 'SHA512')
    
    oJson:FromJson(oRest:GetBodyRequest())
    aBody := oJson:GetNames()

    if (oJwt:ValidUsu(aBody,oJson))

        oPayload["user"] := aParam[1] // Usuario que esta fazendo Login 
        oPayload["pass"] := aParam[2]      // Senha do Usuario
        oPayload["exp"] := FwTimeStamp(4, Date()+1 , IncTime(time(),0,0,0) )  // Tempo que a token espira -- Agora tambem pode ser falado quanto tempo pode ser expirado a token
        oPayload["iat"] := FwTimeStamp(4, Date() , Time() )                 // Dia que a token foi criada 
        oPayload["sub"] := "test"                                           // Sujeito

        cToken := oJwt:Sign(oPayload)

        jResponse["Menssage"] := "Sucessos"
        jResponse["TOKEN_CRIADA"] := cToken

        oRest:setStatusCode(200)
        oRest:setResponse(jResponse)
    Else
        oRest:setStatusCode(401)
        jResponse["Menssage"] := "Usuario Invalido ou Senha invaldida"
        oRest:setResponse(jResponse)
    endif

    if SELECT("SX2") > 0
	  	RESET ENVIRONMENT
  	endif

Return

/*/{Protheus.doc} U_JWTVALID
Validação da token que foi gerada
@type function
@version  12.23.10
@author Felipe Fraga
@since 10/01/2024
@return variant, return
/*/@Get("jwt/valida/token")
Function U_JWTVALID()

    local aTimeStamp                      as Array
    Local jArray    := JsonOBject():New() as Json
    Local jHeader   := Nil                as Json
    Local jResponse := JsonObject():New() as Json
    Local oJwt      := JsonObject():New() as Json
    Local oPay      := JsonOBject():New() as Json

    //É usado o SX6 para verificar o horário de verão
    RpcSetEnv("99","01")

    oJwt := Jwt():New(cKey, 'SHA512')

    jHeader := oRest:getHeaderRequest()

    If oJwt:Verify(Right(jHeader['Authorization'],LEN(jHeader['Authorization']) - RAT(" ", jHeader['Authorization'])), @oPay)
        jArray:FromJson(oPay:toJson())

        aTimeStamp := oJwt:ValidTok(jArray['exp'])

        if (aTimeStamp[1] >= Date() .And. aTimeStamp[2] > TIME()) .Or. (aTimeStamp[1] >= Date() .And. aTimeStamp[2] < TIME())
            oRest:setStatusCode(200)
            jResponse['STATUS'] := "Sucesso"
            jResponse['MESSAGE'] := "Token Valida"
        else
            oRest:setStatusCode(401)
            jResponse['STATUS'] := "ERROR"
            jResponse['MESSAGE'] := "Token Expirada"
        endif
    else
        oRest:setStatusCode(401)
        jResponse["STATUS"] := "ERROR"
        jResponse["MESSAGE"] := "Token Invalida"
    EndIf

    if( jHeader <> Nil )
		//Definindo o header de resposta
		oRest:setKeyHeaderResponse('Connection','Keep-Alive')
		oRest:setKeyHeaderResponse('accept-encoding','gzip,deflate')
		oRest:setKeyHeaderResponse('accept','/')
		oRest:setKeyHeaderResponse('User-Agent','Thunder Client (https://www.thunderclient.com)')
	Endif

    oRest:setResponse(jResponse)

    RpcClearEnv()

Return

/*
UsrExist(RetCodUsr()) -- Retorna se o usuario existe

IIF(PswSeek(RetCodUsr()) .And. PswName(""),.T.,.F.) -- Valida se o usuario que está fazendo o login está correto
*/
